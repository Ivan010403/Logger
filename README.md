<h1 align="center">Simple logger with 3 levels
<h3 align="center">Краткое содержание проекта: описание библиотеки и тестирующего приложения</h3>

# Краткая информация
Проект представляет собой исходный код библиотеки и тестирующего приложения. Для компиляции используется компилятор GCC с флагами компиляции `-std=c++17 -Wall -Wextra`. Автор целенаправленно не использовал другие возможности компилятора (к примеру всякого рода оптимизации) с целью оставить проект лёгким для восприятия и не переусложнить его.

Важный момент: при сборке проекта и создании динамической библиотеки путь для динамического линковщика указывается через `-Wl,-rpath,`, т.е. помогать системе с поиском динамической библиотеке (посредством переменных `LD_LIBRARY_PATH` не нужно).

# Сборка проекта
Для сборки проекта используется утилита **make**. Всё, что вам необходимо сделать, это запустить утилиту внутри директории проекта. Также настроен таргет для очистки временных файлов **clean**. Таким образом, чтобы начать работу достаточно ввести последовательно
```
make
make clean
```
После этого в папке build появится исполняемый файл для тестирующего приложения.

# Библиотека для логирования
Сама библиотека представлена двумя файлами: заголовочный файл, с классом `Logger` и с нужным для реализации перечислением `LoggerLevel`, а также файл реализации. Ключевой элемент библиотеки - это класс `Logger`, именно его мы и будем рассматривать далее.

## Конструкторы и деструктор класса
В классе определены два конструктора: конструктор с параметрами `Logger(const std::string, LoggerLevel)` и копирующий конструктор `Logger(const Logger&)`. Причина, по которой было принято решение реализовать конструктор копирования, связана с передачей логгера внутрь функций ("прокидывание" логера). **Мы крайне советуем использовать передачу по ссылке** (или даже константной ссылке), дабы избежать лишнего копирования, но всё-таки оставляем возможность передавать объект класса по значению и создавать копии. 

Именно допущение копирования данных, при котором два (и более) объекта могут указывать на один объект класса `std::ofstream`, и стало причиной использования умного указателя.

С другой стороны move семантика не подходит для логера (по мнению автора), поэтому соответствующий конструктор был явно запрещён. Также, по мнению автора, не имеет смысла создавать логер без параметров и применять к нему операции копирующего и перемещающего присваивания. Дабы явно указать это, в исходном коде явно запрещены все эти операции.
```
Logger() = delete;
Logger(Logger&& src) = delete;
Logger& operator=(const Logger& src) = delete;
Logger& operator=(Logger&& src) = delete;
```

Деструктор объявлен как деструктор по умолчанию и не выполняет никаких действий `~Logger() = default`.

## Переменные-члены класса

| Private member variable | Description |
| --- | --- |
| std::shared_ptr\<std::ofstream> file_ptr_ | Умный указатель на низлежащий объект класса std::ofstream |
| const std::string filename_ | Константа для хранения имени и расположения файла журнала, полученного от пользователя |
| LoggerLevel default_level_ | Уровень логирования по умолчанию. Сообщения ниже уровнем игнорируются |
| const std::string INFO_P | Константа для вывода в журнал при уровне INFO |
| const std::string WARN_P | Константа для вывода в журнал при уровне WARN |
| const std::string ERROR_P | Константа для вывода в журнал при уровне ERROR |

## Методы класса
В реализации передачи сообщения от пользователя используется тип `std::string_view` с целью минимизации затрат на копирования строк. Также после каждой записи вызывается метод `flush()` с целью немедленной записи в файл, чтобы не потерять буферизированные логи в случае аварийной остановки программы

| Public member function | Description |
| --- | --- |
| void changeLevel(LoggerLevel new_level) noexcept | Сеттер для изменения уровня по умолчанию |
| LoggerLevel getDefaultLevel() const noexcept | Геттер для уровня по умолчанию. Используется, когда пользователь не ввёл уровень важности сообщения |
| void logInfo(std::string_view message) const noexcept | Вызывается, когда поступил запрос на запись с уровнем INFO |
| void logWarn(std::string_view message) const noexcept | Вызывается, когда поступил запрос на запись с уровнем WARN |
| void logError(std::string_view message) const noexcept | Вызывается, когда поступил запрос на запись с уровнем ERROR |

| Private member function | Description |
| --- | --- |
| void createLog(std::string_view message, std::string_view level) const noexcept | Единственный приватный метод, вызываемый методами логирования для отправки соообщения и установки даты |

# Тестирующее приложение
Тестирующее приложение в своей реализации использует многопоточность встроенными средставим языка С++. С целью синхронизации двух потоков (основного потока для получения запроса от пользователя и потока записи в журнал) используются условные переменные и класс-обёртка над обычным мьютексом `std::unique_lock`. Механизм прост:

1. Основной поток ждёт ввода от пользователя (поток записи "спит" после вызова метода `wait()` условной переменной).
2. После получения данных от пользователя основной поток вызывает метод `notify_one()` условной переменной и сам переходит в режим ожидания, пока его не разбудит поток записи.
3. Поток записи передаёт данные в логер, после чего уже сам вызывает `notify_one()` и будит основной поток.

Также входные данные валидируются перегруженной функцией `enterCorrectData()`, которая исключает возможность некорректного ввода от пользователя и обеспечивает устойчивое выполнение программы.
